分类与专题接口的开发
  springbootcode1：
    根据是否为根节点来获取到所有的分类数据，以map的形式(CategoriesAllVO)返回
    同时解决多对多的无限循环问题：
      给Category新增一个CategoryPureVO,同时一定要写构造函数来做属性拷贝：
        public CategoryPureVO(Category category){
            BeanUtils.copyProperties(category,this);
        }



总结：原始数据列表中的数据变为VO列表数据的方法：
  伪代码：
    首先在VO层定义OriginVO的构造函数：
      public OriginVO(Origin origin){
          BeanUtils.copyProperties(origin,this);
      }
    然后进行转换：
      List<Origin> originList = this.xxService.getList();
      List<OriginVO> originVOList = originList.map(r->{
        return new OriginVO(r)
      }).collect(Collectors.toList());
      或：
      List<Origin> originList = this.xxService.getList();
      List<OriginVO> originVOList = originList.stream().map(OriginVO::new).collect(Collectors.toList());


  springbootcode2：grid_category

  springbootcode3：theme接口知识点讲解
    字符串切割：
      List<String> nameList = Arrays.asList("names,age,mty".split(","));
    Respository中，如果自定义了查询的sql语句，那么对应的方法可以自己取，查询会根据自定义的sql进行查询
    自定义JPQL
      如：
      @Query("select t from Theme t where t.name in (:names1)")
      List<Theme> xxx(
            @Param("names1")
            List<String> names
      );
      或：
      @Query("select t from Theme t where t.id > (:id1) and t.id < (:small2)")
      List<Theme> yyy(
            @Param("id1")
            Long id,
            @Param("small2")
            Long small
      );
      
      解决跨域问题：项目中加上该类
        src/main/java/com/whj/springbootcode/configuration/CorsConfiguration.java
