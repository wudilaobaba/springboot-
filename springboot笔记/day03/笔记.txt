
Spring boot的自动配置有什么作用:

IOC的具体实现：
  Step01 容器
  Step02 加入容器  *如何加入容器是重点*
  Step03 然后在将容器中的对象注入到代码中  *注入还是比较简单*
IOC的抽象意义：控制权交给用户

Spring boot的目的：控制权交给用户 & 灵活的OCP


Step01.加入容器：
  以注解方式将实例加入到容器中：
    1.模式注解：在类前面加@Component就会自动将该类的实例加入到容器中
      四大模式注解： 将组件/bean/类加入到容器
        注:
          立即实例化：(建议)
            在springboot启动的时候，就已经在容器中进行实例化了，同时将实例化好的对象注入到代码中了
          延迟实例化：(不建议)
            在bean中加@Lazy注解，但是如果引用该bean的类没有延迟实例化，那么该bean也不会延迟实例化，
            解决以上问题，可以在Controller层的bean中加@Lazy注解，即可实现访问接口的时候才在容器中加入实例，并将实例注入到代码中
        @Component  普通加入容器
        @Service    服务
        @Controller 控制器
        @Repository 数据库
        以上注解一次仅可以加入一个bean到容器中


        @Configuration 自定义加入容器 ：灵活！！！
          01.可以控制哪些bean在什么情况下可以加入到容器中，更灵活
          02.可以给类中的属性赋值，@Component等注解没有这样的功能
            属性的值建议写在xml或yml配置文件中
          03.一次可以加入多个bean到容器中：
            写多个@Bean, 被加入的类中不用写@Component
          04.也可以通过判断来选择来把相同接口的bean选择某一个来加入到容器中，这样代码中不用通过byname的形式进行注入，不需要修改代码了
        可以替代配置原来的xml
        springbootcode3中是@Configuration的使用

        @Configuration都是为了解决以下两种变化，或者同时变化
          面向对象中应对变化的解决方案：
            1.策略模式：制定一个interface,然后用多个类实现同一个interface   防御性编程
            2.配置模式：一个类，属性 解决变化(不够灵活)
            如果以上两种同时变化？

        @Configuration + @Bean 是一种编程模式：通过配置进行编程
          (既要改属性又要加入到IOC容器)，可以应对第二种变化
          既将bean与配置文件绑定在一起，又将bean加入到IOC容器




Step02.从容器中注入到代码里
  三种方式:
    1.属性注入(字段注入 BannerController.class) -> 代码中属性上写@Autowired(required=false)
                  false代表即使该bean没有被加入到容器中，也允许，大不了就是null

    2.构造注入(WhjController.class) -> 注入时不需要写注解
      private Dinana dinana;
      public WhjController(Dinana dinana){//构造函数
          this.dinana =dinana;
      }

    3.setter注入(SetterIn.class) -> @Autowired的注解写在set方法上


@Autowired(required=false)的注入方式：
  1.byname 可以有多个bean实现了某接口 那么需要变量名与类名一致！！
  2.如果是@Component的形式加入容器，那么在类上再使用@Primary，可以有多个bean实现了某接口，优先加载该类,但是必须只能有一个类上有该注解
  3.bytype(默认) 有且只有一个类实现类某接口的bean
  4.指定注入哪个bean
      @Autowired(required=false)
      @Qualifier("指定入bean的类名")
  5.
    ***
      如果是以@Configuration进行加入容器的话，那么注入的时候，属性的名字一定要与‘方法名’一致！！！！！
      谨记：byname & bytype
      bean名就是方法名
    ***
    springbootcode6中根据配置文件进行自定义bean的注入
    @Conditional(IreliaCondition.class)条件注解当然也可以打在普通的@Component类上面，进行自定义加入容器


策略模式的变化方案：
  1.byname 切换bean name
  2.@Qualifier 指定bean
  3.有选择的只注入一个bean，注释掉某个bean上的@Component注解
  4.在类上使用@Primary，优先加载该类,但是必须只能有一个类上有该注解
  5.条件注解 @Conditional
    可以用来编写:自定义条件注解: @Conditional + Condition接口   springbootcode5、6
  内置的成品条件注解：
    @ConditionOnproperty    springbootcode7
    @ConditionOnBean        springbootcode8
      举例：
        @Bean
        @ConditionalOnBean(name="m") //如果有名为m的bean加入到了容器，那么该bean才会被加入到容器
        @ConditionalOnMissingBean(name="m")  //如果有名为m的bean没有加入到了容器，那么该bean才会被加入到容器
        public IConnect m(){
            MySql mySql = new MySql();
            mySql.setIp(this.ip);
            mySql.setPort(this.port);
            return mySql;
        }




依赖倒置DIP：可以更方便的切换实现类
  所有类的定义都要以接口的类型进行定义: springbootcode2中的ISkill.class


@ComponentScan注解是写在ShopserverApplication中的，用来启动容器
@ComponentScan("com.lin")//参数是包名



Spring偏爱配置：
  修改配置文件中的内容不算变化，更符合OCP原则
  OCP：软件开发的开闭原则：保证改动一处，其他地方仍然具有兼容性，将变化隔离到配置文件中
    01. 配置文件具有集中性；
    02. 配置文件很清晰，没有任何逻辑
  HeroConfiguration.class是一个配置类，修改该类中的属性值，也不违反OCP原则
  HeroConfiguration.class就相当于之前的xml配置文件
