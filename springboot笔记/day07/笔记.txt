ORM 面向对象的角度来看待数据库(对象关系映射)
springbootcode1：
jpa:
    hibernate:
      ddl-auto: none  #关闭jpa
      # update #不会删除表
      # create-drop #将表数据清空后再创建表 测试时比较有用
      # none 禁止生成表,设置后，就不会项目启动后就不会创建表了

通过IDEA反向生成model
  View - Tool windows - Database - 加号 - DataSource - MySQL - “测试是否可以链接到数据库.jpg”
  若连接不上，请在mysql命令行中输入：set global time_zone = '+8:00';
  请查看：https://blog.csdn.net/liuqiker/article/details/102455077

  File - Project Structure - Modules - 右键加号Add - JPA - 最下面Default JPA Privoder选择Hibernate - Apply - OK
  View - Tool windows - Persistence - 面板中就可以看到所有有@Entity注解的模型了
  (因为之前有手动写过@Entity的模型，那么此处就会出现所有@Entity模型，但实际上，不需要自己写，
  这一步的目的是根据数据库表生成@Entity模型类)
  右键项目名 - Generate Persistence Mapping - By Database Schema - Choose Database Source - 清空Entity suffix - 选择Package - OK - yes
  (要保证模型的类名与表名一致)
  生成模型以后，进入模型代码中：
    01.刪除所有get set equles hashCode方法，
    02.在类上加@Getter和@Setter,
    03.@Id主键不要忘记加
    04.字段类型检查并修改


springbootcode2：
  自定义BaseEntity基类：
    在字段前加上@JsonIgnore注解，那么前端将不会返回该字段
  访问Banner接口
  application.yml中添加：
    jackson:
      property-naming-strategy: SNAKE_CASE #所有返回前端的字段都已下划线的形式返回
      serialization: #时间全部以时间戳的形式返回
        WRITE_DATES_AS_TIMESTAMPS: true

springbootcode3：
  banner未找到的话，要向前端抛出异常
  Spu详情、Spu列表接口开发
  静态资源托管的处理方法：
    STEP01.安装依赖
      <dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-thymeleaf</artifactId>
  		</dependency>
    STEP02.静态资源放在resource/static目录下 ：http://localhost:8599/imgd/1.jpg

springbootcode4：
  SpuImg
  SpuDetailImg
  观察.sql语句，如果一个实体A中包含了实体B的id字段，那么B对A就是一对多的关系

springbootcode5： vo视图层的出现
  Step01. vo中创建SpuSimplifyVO对象，并将Spu中需要的属性复制进来，同时加上@Getter、@Setter
  Step02. controller中，将查到的实际数据进行处理：
      01. SpuSimplifyVO vo = new SpuSimplifyVO();
      02. Spu spu = this.spuService.getSpuDetail(id);
      03. BeanUtils.copyProperties(spu,vo);
      经以上三步，此时的vo对象就是实际的vo字段对象了

  <!-- 将vo层的对象添加到一个List中返回 -->
		<dependency>
			<groupId>com.github.dozermapper</groupId>
			<artifactId>dozer-core</artifactId>
			<version>6.5.0</version>
		</dependency>
  Step01. 项目中引入以上包
  Step02. 在controller中的具体实现方法如下：
    @RequestMapping(value="/latest", method={RequestMethod.GET,RequestMethod.POST})
    public List<SpuSimplifyVO> getLatestSpuList(){
        //数据库查询到的原始数据
        List<Spu> spuList = this.spuService.getLatestPagingSpu();

        //定义转换为vo的对象，固定写法
        Mapper mapper = DozerBeanMapperBuilder.buildDefault();
        List<SpuSimplifyVO> vos = new ArrayList<>();

        //循环遍历转换vo并追加到vos中
        spuList.forEach(s->{//s就是每一个spu
            SpuSimplifyVO vo = mapper.map(s,SpuSimplifyVO.class);//第二个参数是目标对象的原类
            vos.add(vo);
        });

        return vos;
    }

springbootcode6： 分页的封装
  移动端一般都是上拉加载，那么分页的传参就会与PC端不同
  此时，前端传参要传(start从哪一条开始传，count传递数量)
  前端传参要进行问号的形式传参
  后端逻辑：
    STEP01.controller中使用@RequestParam注解来接收前端问号后面传来的参数
    STEP02.service中使用PageRequest进行分页处理
    STEP03.util/CommonUtil/converToPageParameter方法进行条目起始数转换为页码的操作
    STEP04.bo层的出现(业务对象，即service向controller中传递的数据)
    STEP05.vo层中添加一个返回给前端的分页对象Paging

springbootcode7: vo中新增PagingDozer对象的封装，使得既可以拷贝属性，又可以返回分页对象
  此时controller中只要涉及到分页，就写以下三行代码即可：
      //将start转换为页码
      PageCounter pageCounter = CommonUtil.converToPageParameter(start,count);
      //数据库查询到的原始数据列表,getLatestPagingSpu中的参数是页码
      Page<Spu> page = this.spuService.getLatestPagingSpu(pageCounter.getPageNum(),pageCounter.getCount());
      //使用PagingDozer的构造函数返回pagingDozer
      return new PagingDozer<>(page, SpuSimplifyVO.class);
                                            //目标vo原类

几个Page的上下文梳理： 3使用2, 2使用1, 0是为了将当前条目索引值转化页码
0. PageCounter pageCounter = CommonUtil.converToPageParameter(start,count);
1. Pageable pageable = PageRequest.of(pageNum,size, Sort.by("createTime").descending());//可以不在这里写排序的条件，在JPA的查询方法中写排序方法名
2. Page<Spu> pageSup = this.spuRepository.findAll(pageable); //JPA的查询方法中传入Pageable对象返回Page列表，JPA的查询方法的条件参数如id该传的时候必传
3. return new PagingDozer<Spu,SpuSimplifyVO>(pageSup, SpuSimplifyVO.class); 或：
   return new Paging<Spu>(pageSup);


对象属性拷贝总结：
  拷贝单个对象：
        SpuSimplifyVO vo = new SpuSimplifyVO();
        Spu spu = this.spuService.getSpuDetail(id);//数据库查询出来的真实对象
        if(spu == null){
            throw new NotFoundException(30003);
        }
        BeanUtils.copyProperties(spu,vo);
        //此时，vo就变成了一个深度拷贝后，拥有SpuSimplifyVO中字段的实体
  拷贝List
          Mapper mapper = DozerBeanMapperBuilder.buildDefault();
          List<SpuSimplifyVO> vos = new ArrayList<>();
          spuList.forEach(s->{//s就是每一个spu
              SpuSimplifyVO vo = mapper.map(s,SpuSimplifyVO.class);//第二个参数是目标对象的原类
              vos.add(vo);
          });
          return vos;


分页总结：
  1.未来想要进行分页并进行属性精简，就使用PagingDozer；
  2.未来只是想要进行分页，就使用Paging，使用方式也是三行代码，如下：
      //将start转换为页码
      PageCounter pageCounter = CommonUtil.converToPageParameter(start,count);
      //数据库查询到的原始数据列表,getLatestPagingSpu中的参数是页码
      Page<Spu> page = this.spuService.getLatestPagingSpu(pageCounter.getPageNum(),pageCounter.getCount());
      //使用PagingDozer的构造函数返回pagingDozer
      return new Paging<>(page);



JPA的查询方法总结：
  repository中：
    findOneByxxx
    findByCategoryxxx //根据字段名获取列表数据
  service
    findAll
    findAllByxxx


注：
  前端参数校验@NotNull适用于数字，@NotBlank适用于字符串
  导航关系不是必须配置的，导航关系的字段不是数据库中的，但是有了导航关系可以更好的查询数据
